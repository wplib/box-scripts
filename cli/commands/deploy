#!/usr/bin/env bash

declare="${ECHO_PREFIX:=}"
declare="${GREEN:=}"
declare="${YELLOW:=}"
declare="${RED:=}"
declare="${CYAN:=}"
declare="${WHITE:=}"
declare="${RESET:=}"
declare="${LESS:=}"
declare="${BOX_PROJECT_DIR:=}"
declare="${BOX_PROJECT_FILE:=}"

function deploy_help() {
	cat <<EOF

${YELLOW}WPLib Box ${GREEN}CLI${RESET} ${GREEN}deploy${RESET} usage:

box ${YELLOW}deploy${RESET}	        - Show this help.
box ${YELLOW}deploy ${GREEN}help${RESET}		- Show this help.
box ${YELLOW}deploy ${RESET}[${CYAN}<host>]${RESET}	- Deploys the host as defined in ${GREEN}project.json${RESET}.

EOF
}

function deploy_host() {

    local DEPLOY_LOG="/tmp/box-tmp/deploy.log"
    rm -rf "${DEPLOY_LOG}"

    initErrorFile

    local host_id="$1"

    if [ "" == "${host_id}" ]; then
        output "Hostname required when calling 'deploy'"
        exit
    fi

    check_deploy_host "${host_id}"
    exitOnError

    source_url="$(get_source_repo_url)"
    exitOnError

    source_dir="$(get_raw_repo_cache_dir "${source_url}")"
    exitOnError

    source_branch="$(get_source_repo_branch "${host_id}")"
    exitOnError

    deploy_url="$(get_raw_host_repo_url "${host_id}")"
    exitOnError

    deploy_dir="$(get_raw_repo_cache_dir "${deploy_url}")"
    exitOnError

    deploy_branch="$(get_raw_deploy_host_branch "${host_id}")"
    exitOnError

    ################ensure_no_uncommitted_files

    output
    output "${YELLOW}Preparing to deploy:${RESET}"
    output
    output "   ${CYAN}Source branch: ${GREEN}${source_branch}${RESET}"
    output "   ${CYAN}Source repo:   ${GREEN}${source_url}${RESET}"
    output
    output "   ${CYAN}Deploy branch: ${GREEN}${deploy_branch}${RESET}"
    output "   ${CYAN}Deploy repo:   ${GREEN}${deploy_url}${RESET}"
    output

    output "   ${YELLOW}Updating repository caches...${RESET}"

    ensure_repo_cached_locally "${source_url}" "${source_branch}" >> $DEPLOY_LOG 2>&1

    ensure_repo_cached_locally "${deploy_url}" "${deploy_branch}" >> $DEPLOY_LOG 2>&1

    output "   ${YELLOW}Running Composer Install on source...${RESET}"

    ensure_source_composer_install "${source_dir}" >> $DEPLOY_LOG 2>&1

    #
    # Sync vendor path files
    #
    sync_files_deep "${source_dir}" "${deploy_dir}" \
        "$(get_raw_source_wp_vendor_path)" \
        "$(get_raw_deploy_wp_vendor_path)"  >> $DEPLOY_LOG

    #
    # Sync content path files
    #
    sync_files_deep "${source_dir}" "${deploy_dir}" \
        "$(get_raw_source_wp_content_path)" \
        "$(get_raw_deploy_wp_content_path)"  >> $DEPLOY_LOG

    local wp_source_core_path="$(get_raw_source_wp_core_path)"
    local wp_deploy_core_path="$(get_raw_deploy_wp_core_path)"

    #
    # Sync core wp-admin path files
    #
    sync_files_deep "${source_dir}" "${deploy_dir}" \
        "${wp_source_core_path}/wp-admin" \
        "${wp_deploy_core_path}/wp-admin"  >> $DEPLOY_LOG

    #
    # Sync core wp-includes path files
    #
    sync_files_deep "${source_dir}" "${deploy_dir}" \
        "${wp_source_core_path}/wp-includes" \
        "${wp_deploy_core_path}/wp-includes"  >> $DEPLOY_LOG

    #
    # Sync core root files
    # Copy *just* the files in www/blog/ and not subdirectories
    # See: https://askubuntu.com/a/632102/486620
    #
    sync_files_shallow \
        "${source_dir}" \
        "${deploy_dir}" \
        "${wp_source_core_path}" \
        "${wp_deploy_core_path}"  >> $DEPLOY_LOG

    remove_deploy_delete_files "${deploy_dir}"  >> $DEPLOY_LOG

    echo "Deploy complete."

}

function remove_deploy_delete_files() {
    local deploy_dir="$1"
    checkParam "${deploy_dir}" "You must pass a destination directory as 1st argument to remove_deploy_delete_files()."
    exitOnError

    local exclude_files="$(get_raw_deploy_delete_files)"
    local saveIFS="${IFS}"
    IFS=$'\n'
    for file in $exclude_files ; do
        file="${deploy_dir}${file}"
        if [ "" == "$(ls ${file} 2>/dev/null)" ] ; then
            echo "Skipping deletion of ${file} [File not found.]"
            continue
        fi
        echo "Deleting ${file}"
        rm -rf "${file}"
    done
    IFS="${saveIFS}"
}

function sync_files_shallow() {

    local source_dir="$1"
    checkParam "${source_dir}" "You must pass a source directory as 1st argument to sync_files_shallow()."
    exitOnError

    local deploy_dir="$2"
    checkParam "${deploy_dir}" "You must pass a destination directory as 2nd argument to sync_files_shallow()."
    exitOnError

    local source_path="$3"
    checkParam "${source_path}" "You must pass a source path as 3rd argument to sync_files_shallow()."
    exitOnError

    local deploy_path="$4"
    checkParam "${deploy_path}" "You must pass a destination path as 4th argument to sync_files_shallow()."
    exitOnError

    local exclude_files_list="$(write_sync_exclude_files_by "path" "${source_path}")"

    rsync --archive --filter="- */" --filter="+ *" --exclude-from="${exclude_files_list}" \
        "$(RTrimSlashes "${source_dir}${source_path}")" \
        "$(RTrimSlashes "${deploy_dir}${deploy_path}")"

}

function sync_files_deep() {
    local source_dir="$1"
    checkParam "${source_dir}" "You must pass a source directory as 1st argument to sync_files_deep()."

    local deploy_dir="$2"
    checkParam "${deploy_dir}" "You must pass a destination directory as 2nd argument to sync_files_deep()."
    exitOnError

    local source_path="$3"
    checkParam "${source_path}" "You must pass a source path as 3rd argument to sync_files_deep()."
    exitOnError

    local deploy_path="$4"
    checkParam "${deploy_path}" "You must pass a destination path as 4th argument to sync_files_deep()."
    exitOnError

    local exclude_files_list="$(write_sync_exclude_files_by "path" "${source_path}")"

    rsync --archive --delete-after --verbose \
        --exclude ".git" --exclude ".git*" --exclude-from="${exclude_files_list}" \
        "${source_dir}${source_path}/" \
        "${deploy_dir}${deploy_path}"

    rm -rf "${exclude_files_list}"

}

function get_raw_deploy_exclude_files() {
    local exclude="$(get_raw_deploy | jqr ".files.exclude[]")"
    echo "${exclude}"
}

function get_raw_deploy_delete_files() {
    local exclude="$(get_raw_deploy | jqr ".files.delete[]")"
    echo "${exclude}"
}

function write_sync_exclude_files_by() {
    local by="$1"
    local value="$2"

    mkdir -p /tmp/box-tmp/
    local exclude_file_list="$(mktemp /tmp/box-tmp/exclude-XXXX.txt)"
    touch "${exclude_file_list}"
    local exclude_files="$(get_sync_exclude_files)"
    if [ "" != "${value}" ] ; then
        case "${by}" in
        'path')
            saveIFS="${IFS}"
            IFS=$'\n'
            for file in $exclude_files ; do
                if [ "/" == "${file:0:1}" ] ; then
                    # if not an absolute reference, then file is to be excludes everywhere
                    echo -e "${file}" >> $exclude_file_list
                    continue
                fi
                if ! [[ ${file} =~ ^${value}/(.+)$ ]] ; then
                    continue
                fi
                echo -e "/${BASH_REMATCH[1]}" >> $exclude_file_list
            done
            IFS="${saveIFS}"
            ;;

        *)
            alert "The criteria [${by}] is not valid for get_sync_exclude_files_by()"
            exit 1
            ;;

        esac
    fi
    echo "${exclude_file_list}"
}

function get_sync_exclude_files() {
    local exclude_files="$(get_raw_deploy_exclude_files)\n$(get_raw_deploy_delete_files)\n$(get_raw_deploy_keep_files)"
    echo -e "${exclude_files}"
}

function ensure_source_composer_install() {
    local repo_dir="$1"
    checkParam "${repo_dir}" "You must pass a repository directory as 1st argument to ensure_source_composer_install()."
    exitOnError
    output "Running Composer to install externals."
    pushDir
    cd "${repo_dir}"
    composer install
    exitOnError
    popDir
}

function simplify_pantheon_repo_cache_dir() {
    local repo_url="$1"
    checkParam "${repo_url}" "You must pass a repository URL as 1st argument to simplify_pantheon_repo_cache_dir()."
    exitOnError
    local provider="$(get_raw_project_file | jq -r '.deploy.provider')"
    if [ "pantheon" == "${provider}" ] ; then
        local site_id="$(get_raw_project_file | jq -r '.deploy.site_id')"
        local site_name="$(get_raw_project_file | jq -r '.deploy.site_name')"
        repo_url="${repo_url//\.${site_id}/}"    # Replace guid with URL name
        repo_url="${repo_url//\/2222\/~\/repository/\/${site_name}}"  # Remove goggledegook
    fi
    echo "${repo_url}"
}

function make_cache_dir() {
    cache_dir="$1"
    mkdir --parents "${cache_dir}"
}

function get_raw_repo_cache_dir() {
    declare=${BOX_CACHE_DIR:=}
    local repo_url="$1"
    checkParam "${repo_url}" "You must pass a repository URL as 1st argument to get_raw_repo_cache_dir()."
    exitOnError
    local path="${repo_url}"
    path="${repo_url#*://}"     # Strip leading protocol; ssh://, https://, http://
    path="${path#*@}"    # Strip leading username, e.g. git@
    path="${path%.git*}"        # Strip trailing .git extension
    path="${path/:/\/}"         # Replace ':' with '/'
    local cache_dir="${BOX_CACHE_DIR}/${path}"
    cache_dir="$(simplify_pantheon_repo_cache_dir "${cache_dir}")"
    echo "${cache_dir}"
}

function check_deploy_host() {
    local host_id="$1"
    checkParam "${host_id}" "You must pass a host name/id as 1st argument to check_deploy_host()."
    exitOnError
    echo "$(get_deploy_host "${host_id}")" > /dev/null
}

function get_deploy_host() {
    local host_id="$1"
    checkParam "${host_id}" "You must pass a host name/id as 1st argument to get_deploy_host()."
    exitOnError
    json="$(cat "${BOX_PROJECT_FILE}" | jq -r ".deploy.hosts.${host_id}?")"
    if [ "object" != "$(echo "${json}"|jqr 'type')" ]; then
        alert ""
        alert "ERROR: ${RED}Your ${GREEN}project.json${RED} file does not define a host named ${YELLOW}\"${GREEN}${host_id}${YELLOW}\"${RED}.${RESET}"
        alert ""
        alert "Please edit your ${GREEN}project.json${RESET} file and add ${YELLOW}\"${GREEN}${host_id}${YELLOW}\"${RESET} as a property of ${GREEN}.hosts.${RESET}"
        alert ""
        exit 1
    fi
    echo -e "${json}"
}

function get_source_repo_url() {
    local source_repo_url="$(get_raw_source_repo_url)"
    local remote_repo_url="$(get_git_origin_remote_repo_url)"
    if [[ "${source_repo_url}" =~ ^ssh:// ]]; then
        source_repo_url="${source_repo_url#*//}"
    fi
    if [ "${source_repo_url}" != "${remote_repo_url}" ]; then
        alert ""
        alert "${RED}Your source repo and your git remote repo do not match. Cannot deploy.${RESET}"
        alert ""
        alert "\tSource: ${source_repo_url}"
        alert "\tRemote: ${remote_repo_url}"
        alert ""
        alert "Your source repo is found in ${BOX_PROJECT_FILE} as '.source.repository.url.'"
        alert "Your remote is found by running 'git remote -v'. You can set your remote to match your source with:"
        alert ""
        alert "\tgit remote set-url --push origin ${source_repo_url}"
        alert ""
        exit 1
    fi
    echo "${source_repo_url}"
}

function get_source_repo_branch() {
    local host_id="$1"
    local project_branch="$(get_raw_source_branch_by "host" "${host_id}")"
    exitOnError
    local current_branch="$(get_current_git_branch)"
    exitOnError
    if [ "null" == "${project_branch}" ] ; then
        project_branch="n/a"
    fi
    if [ "${current_branch}" != "${project_branch}" ]; then
        alert ""
        alert "${RED}Your current branch does not match the deploy branch for the ${GREEN}${host_id}${RED} host."
        alert "Cannot deploy.${RESET}"
        alert ""
        alert "\t${CYAN}Current Branch: ${GREEN}${current_branch}${RESET}"
        alert "\t${CYAN}Requested Deploy Host: ${GREEN}${host_id}${RESET}"
        alert "\t${CYAN}Deploy branch for host ${RED}${host_id}${RESET}: ${GREEN}${project_branch}${RESET}"
        alert ""
        if [ "n/a" == "${project_branch}" ] ; then
            alert "${RED}Review your project.json file to ensure you have a host ${GREEN}${host_id}${RED} defined in"
            alert "the ${GREEN}.host${RED} section.${RESET}"
        else
            alert "${YELLOW}You can set switch to the project branch for host ${GREEN}${host_id}${YELLOW}, assuming \nall files in your current branch have been committed using:${RESET}"
            alert ""
            alert "\t${GREEN}git checkout ${project_branch}${RESET}"
        fi
        alert ""
        exit 1
    fi
    echo "${current_branch}"
}

function ensure_no_uncommitted_files() {
    local uncommitted_files="$(get_git_uncommitted_files)"
    local file
    if [ "" != "${uncommitted_files}" ]; then
        alert ""
        alert "${RED}Your current branch has uncommitted files. Cannot deploy.${RESET}"
        alert ""
        saveIFS="${IFS}"
        IFS=$'\n'
        for file in $uncommitted_files ; do
            alert "\t${GREEN}${file}${RESET}"
        done
        IFS="${saveIFS}"
        alert ""
        exit 1
    fi
}


################################################################################
CMD="$1"
shift
case $CMD in
    'help')
        ;;

	*|'help')

        if [ "" == "${CMD}" ] ; then
            deploy_help
            exit 1
        fi
        deploy_host "${CMD}"
		;;
esac

